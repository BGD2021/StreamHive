这是一个可以在RK3588上运行的yolov5-demo项目，主要功能是将usb摄像头的画面进行实时推理再推流，使用了线程池加速推理，rkmpp进行硬件编码，流媒体使用的是ZLMdiakit的SDK
---
+ 数据流转
编码器指针 mpp_frame ---->  src
img ----->  rga_buffer_t ----->   指向编码器缓冲区 src -----> 从mpp_frame指针编码图像成enc_data   ----->  向媒体流输入h264数据 enc_data  ------>   
---
# 更新记录
## beta
+ 内存泄漏：rknn_init后没有释放模型资源，增加free（）
+ 内存泄漏：rknn_output_to_tensor_data(rknn_outputs[i], outputs[i]);后没有release，增加release
+ 多线程优化，增加生产者、消费者模型，
+ 模型分配方式，原来通过原子计数，现在通过一个自增id进行分配，保证模型的均匀分配
+ 优化了帧率的计算方式，原来是计算1秒内过了n帧，现在使用滑动窗口进行计算，设置n个窗口，每帧保存一次时间戳，窗口长度/最后一次时间减去第一次时间
+ 使用rga加速前处理部分，修改cvimg2tensor函数，减少了数据拷贝
+ 更新了后处理的实现process部分，踩了大量的坑，一开始以为是数组越界导致的卡死，怀疑是模型的通道问题，后面怀疑是模型的量化问题，后面发现只是处理的时间需要非常久，将每个输出的候选框validCount打出来才发现是阈值的问题导致了上万个框的后处理，原来的模型输出是不带归一化的，现在的模型是带归一化（sigmoid）的，导致反复归一化，阈值变低，并且反量化部分也出错。
+ 新增main.cpp，实现支持网络摄像头实时识别，新增decoder进行rtsp视频流解码，修改线程池的输出为RGA格式，减少了RGA转MAT再转RGA的多余步骤。
+ 新增config库，使用jsoncpp库实现通过json文件进行启动配置。
## v1.1
+ 更新至v1.1版本，新增RtspWorker类管理单个视频流的拉流、解码、推理、编码、推流调度，原本设计四个线程和一个线程池去异步执行任务，但是发现上下文开销太大，出现了很多没必要的数据传输，尤其是图像的传输，图像大多数情况使用的是指针去传输，只传输图像的地址，太多的线程很难管理图像指针的生命周期，以至于后面出现悬空指针，大量的出现段错误，这都是在1.0版本中遇到的问题，因此1.0版本已经废弃了，并且zlm对于异步操作的支持感觉没有这么好，会出现很多变量被提前释放掉的情况，并不想加入过多的智能指针以至于后面很难管理变量的生命周期，并且对于性能没有太大的提升，所以将拉流、解码作为一个拉流类AvPullStream，线程池单独分出，编码、推流作为推流类AvPushStream，通过worker统一调度，线程之间数据传输统一使用安全队列保证线程安全，接下来的优化方向是数据流转和内存管理。
+ 修改bug：发现程序正常运行但是使用流播放器无法播放，检查了track是否为空、推理后结果是否为空、编码器的输出是否正常，发现都是正常，后面发现日志中有一条信息为“unkown type fmp4”，后面是media初始化失败，创建pusher失败，那肯定无法成功推流，后面修改了media的注册函数，成功初始化了pusher，但是发现还是失败，对比测试版代码发现是推流的地址first和second没有传进来，导致为空，在worker的构造函数中没有传参进来。
+ 修改bug：新增多路worker后发现只能成功初始化一路视频流，后面的都失败了，原因是zlm服务的初始化写在worker的构造函数中，导致了rtsp服务器的多次创建导致的创建失败。
+ 修改bug：程序的执行过程中随机出现malloc的报错信息，导致程序意外退出，原因是资源被重复释放，优化了资源释放逻辑，对于上下文中的资源在worker的析构函数中统一释放，对于zlm的player、media、pusher等资源在拉流和推理线程中统一管理，这样的优化策略可以保证线程中使用ctx的资源不会意外删除，导致程序错误退出，并且能保证资源释放干净。
+ 修改bug: 新增了安全退出策略，通过控制台输入命令来安全退出，但是总会出现有线程没有退出，导致程序无法退出，无法正常进入析构函数，资源释放不对，经过排查发现在worker的stop函数中修改的running变量是worker的局部变量，但是控制线程停止的变量是ctx中的running变量，原因二为在推流线程中尝试从安全队列中取出图像帧，这个函数是阻塞的，并且是由一个条件变量来控制，由于拉流线程已经停了，无法唤醒pop取出帧，导致推流线程在pop中卡死，优化方案一为，修改安全队列逻辑，增加带超时控制的pop函数，方案二为增加退出信号量，在worker中发送退出信号唤醒所有线程退出，方案三为增加一条if语句，在安全队列中有元素的情况下才去调用pop，在推流线程结束之后图像帧很快会被pop完，此时拉流线程无法在进入pop函数也不会阻塞，最终选用了方案三由于其简单且不需要修改原有接口，防止出现意料之外的情况。
+ 优化config类，原json文件格式更多的是设置一些全局变量，必须增加多层结构来分别保管全局变量，视频流配置信息，并且可以导入批量数据，也就是可以读入n个视频流信息，使程序更具灵活性。
+ 新增MultiStreamManager类用于管理多路视频流，是视频流调用的抽象封装，配合优化的config类，可以支持多路视频流的启停、查询状态、批量修改，比直接管理worker要优雅得多。
+ 新增multi_stream_main.cpp来实现多路推流




## v1.3
+ 该版本由v1.1拓展而来，在v1.2中增加了zmq做tcp数据传输，修改线程池将推理结果传出来，但是由于经验不足，产生了线程竞态问题和图像的生命周期问题，于是直接废弃，回溯到v1.1进行更新。
+ 新增功能：修改了线程池传出结构体，包含推理后图像和推理结果，可从推流线程中读出推理结果以便后续进行传输。
+ 更改结构：原本为了解决图像的生命周期问题，一直在魔改推流线程，将推入线程池的步骤也写入了推流线程，导致出现了更恶心的生命周期问题，后面发现其实图像的生命周期一直都是由拉流函数那边决定的，后续传递的都是指针，现在使用深拷贝的方式来保证图像的生命周期，同时可以删除线程间图像传输这一冗余的安全队列，直接将图像深拷贝后推入线程池，实现了真正意义上的生产者消费者模型。
+ 修改bug：后面发现每次程序运行只能撑五六分钟就会中断，一直报错的都是内存管理问题，大部分意思是malloc的时候没有拿到完整的对齐的数据，推测大多数原因在于enc_data的创建，因为只有这里出现了大量的malloc使用，根据copilot的提示尝试将enc_data改成vector去自动的管理内存，然而这是一个烟雾弹，改了之后无法正常推流，后面对比之前的测试版本，增加了在第一帧的时候获取视频的header，还有只有在enc_data为nullptr的时候才去free，之前一直都是每次都去free(enc_data)，导致了重复释放，并且产生大量的内存碎片，导致长时间运行后，程序无法拿到完整的内存空间。
+ 疑点：现在有个很离谱的情况，当我使用
cmake -DCMAKE_CXX_FLAGS="-g -O0 -fsanitize=address -fno-omit-frame-pointer" \
      -DCMAKE_C_FLAGS="-g -O0 -fsanitize=address -fno-omit-frame-pointer" ..
来构建makefile，程序可以正常运行。当我使用cmake ..构建后工程会出现malloc报错。

## v1.4
+ 解释疑点：在V1.3中遗留的疑点是由于加入了asan工具，用这个工具运行代码可以检测内存问题，同时在申请空间的时候会预留出保护的空间防止写越界、读越界，还会自动进行内存对齐，所以才会出现那个现象，
+ 修复bug：在V1.3中一直怀疑是推流线程中enc_data的问题，导致的写越界，后面经过gdb来调试，发现问题出在拉流线程中将Mat图像推入安全队列这个部分，在clone的时候出现了报错，原因是申请内存失败，但此时内存还较为富足，说明并不是内存泄漏导致的空间问题，而且如果不是推流的问题，那么也不存在生命空间的问题了，所以那个安全队列完全不需要，只要把Mat进行深拷贝或者使用智能指针管理生命周期就已经能保证Mat的生命周期了，于是舍弃掉了安全队列，一个视频流的三个部分也做到了真正解耦，解码后直接推入线程池，推流线程从线程池中取出然后再编码推流。但是内存问题仍然存在，我最终做了两次尝试将问题定位到了内存碎片化问题，一个是单开一路视频流，发现不会出现malloc报错，能够正常运行，这说明问题并不出现在生命周期中，也验证了之前的结论；第二个是在申请Mat内存的时候将图像全部resize到统一的480p再申请内存，当时是为了验证内存空间不够分配，后面发现仍然可以正常运行，说明就是在多路不同尺寸视频流创建Mat的时候出现的报错，后面了解到如果频繁的内存操作可能会导致出现大量内存碎片，导致内存空间碎片化，进而无法申请出一块完整的内存，也会造成内存不能正常对齐，也就是出现的之前的报错，访问没对齐的内存，由于图像帧的速度很快，频繁的内存操作会带来一定的安全问题还会影响性能，为了后端架构的灵活性，最终舍弃了统一视频尺寸的方案，使用内存池解决内存碎片问题，创建了MatPool类，预设720p、480、1080p三种分辨率的内存池，在创建mat的时候通过内存池进行创建。
+ 新增功能：使用ZeroMQ库来进行QT进程和后端进程的信息交互，新增MsgServer类，为了数据交互框架足够的简洁，将数据分为了两种：报警信息和RTSP地址信息，分别开在5555端口和5556端口，方便QT端进行解析。
+ 新增功能：修改RTSP地址信息线程，现在传输json格式，增加了流id和流name，且便于后期拓展。
+ 修复bug：工程长期运行时发现视频流的延迟很大，并且还会出现延迟累积，对于安防型项目这是致命的问题，也就是失去了实时性，一开始会怀疑的是时间戳的问题导致了ZLM进行了大量缓存，并且时间计算错误也会导致延迟累积，修改了时间戳的计算逻辑，从原来的灵活计算时间戳变成定帧计算，按照30fps的速度进行推流，问题仍然存在，换了好几种时间戳的计算方式仍然无法解决，灵活计算时间戳也确实更适合这个项目，觉得问题并不出现在时间戳，而是线程之间的速率不匹配问题，可能是线程池出现了任务堆积或者是推流时编码操作过于耗时导致的图像帧推积，后面打印了空帧跳过的频率还有线程池中队列长度，发现没有出现堆积，并且推流线程执行速度完全超过了线程池推理的速度，因此问题出现在了拉流线程，拉流线程执行过慢导致图像过慢，拉流线程的执行速度是通过设置解码器的帧率来控制的，在beta版本中是写死的30帧，实时性很好，现在是通过拉流得到的track确定的帧率，但可能这个帧率控制并不是很准，导致了解码过慢，所以回溯到beta版本写死30帧，解决了延迟问题。由于有推理池来作为缓冲，大于实际帧率也不会出现问题。
+ 优化功能：重构msgServer类，原本设计的msgServer是作为单个tcpServer的最小单元，将server传入worker中进行使用，但随着功能的增加，如控制发送时间间隔、控制检测对象如果都需要传入至推流线程来处理，大大增加了推流线程的工作量影响性能，并且与推流线程深度耦合，重构后的msgServer作为控制整个后端与前端交互的server，推流线程只需要将结果推入安全队列，到msgServer中的线程再进行处理，实现了可拓展性和功能解耦。
+ 优化功能：优化安全队列，由于推流线程推入推理结果的速度比取出的速度差异过大，会造成队列中的结果堆积，前端无法看到最新的实时的报警信息，所以在安全队列中增加了最大队列长度，当达到最大长度将不再接收数据，可以保证发送报警数据接口的灵活性，不需要增加多余的逻辑，并且可以保证发送的报警信息是实时的。

---
+ 用法
mkdir build && cd build
cmake ..
sudo ./main -f <config.json>

+ 示例
sudo ./main -f ../config.json

+ 运行部分日志
[NN_INFO] device_mask=7
[NN_INFO] rknn_init success!
[NN_INFO] RKNN API version: 1.5.3b6 (181ec8d8b@2023-09-12T17:11:43)
[NN_INFO] RKNN Driver version: 0.9.0
[NN_INFO] model input num: 1, output num: 3
[NN_INFO] input tensors:
[NN_INFO]   index=0, name=images, n_dims=4, dims=[1, 640, 640, 3], n_elems=1228800, size=1228800, fmt=NHWC, type=INT8, qnt_type=AFFINE, zp=-128, scale=0.003922
[NN_INFO] output tensors:
[NN_INFO]   index=0, name=output0, n_dims=4, dims=[1, 255, 80, 80], n_elems=1632000, size=1632000, fmt=NCHW, type=INT8, qnt_type=AFFINE, zp=69, scale=0.093581
[NN_INFO]   index=1, name=327, n_dims=4, dims=[1, 255, 40, 40], n_elems=408000, size=408000, fmt=NCHW, type=INT8, qnt_type=AFFINE, zp=49, scale=0.085973
[NN_INFO]   index=2, name=328, n_dims=4, dims=[1, 255, 20, 20], n_elems=102000, size=102000, fmt=NCHW, type=INT8, qnt_type=AFFINE, zp=43, scale=0.083459

double free or corruption (!prev)
已放弃
corrupted double-linked list
已放弃
malloc_consolidate(): unaligned fastbin chunk detected
已放弃
malloc(): unaligned tcache chunk detected
已放弃